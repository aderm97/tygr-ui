# Vulnerability Feed Implementation Plan (Priority)

## Overview
Focused implementation plan for real-time vulnerability monitoring feed, prioritized as the most critical feature.

## Implementation Steps

### Phase 1: Enhanced Python Tracer for Vulnerability Events

**Goal**: Modify the existing Tracer to emit structured JSON events when vulnerabilities are discovered.

#### Changes to `strix/telemetry/tracer.py`:

1. **Add JSON Event Emission**:
   ```python
   def add_vulnerability_report(self, title: str, content: str, severity: str) -> str:
       # Existing logic...
       report_id = super().add_vulnerability_report(title, content, severity)
       
       # Emit structured event
       event = {
           "event_id": f"vuln-{uuid4().hex[:8]}",
           "timestamp": datetime.now(UTC).isoformat(),
           "hunt_id": self.run_id,
           "type": "vulnerability_found",
           "data": {
               "report_id": report_id,
               "title": title.strip(),
               "content": content.strip(),
               "severity": severity.lower().strip(),
               "agent_id": self._current_agent_id,  # Track which agent found it
               "location": self._extract_location(content),  # Parse file/endpoint
               "cvss_score": self._extract_cvss(content),  # Parse if available
           }
       }
       
       # Emit to stdout for streaming
       print(f"###VULN_EVENT###{json.dumps(event)}", flush=True)
       return report_id
   ```

2. **Add Event Stream Mode**:
   ```python
   def __init__(self, run_name: str, stream_events: bool = False):
       super().__init__(run_name)
       self.stream_events = stream_events
       self._current_agent_id = None
   ```

### Phase 2: Next.js API Event Stream Processing

**Goal**: Create API endpoint that captures and streams vulnerability events.

#### New File: `tygr/src/lib/event-capture.ts`:

```typescript
import { EventEmitter } from 'events'
import { spawn, ChildProcess } from 'child_process'

export class HuntEventCapture extends EventEmitter {
  private process: ChildProcess | null = null
  private eventBuffer: any[] = []
  private isCapturing = false

  constructor(private huntId: string) {
    super()
  }

  start(strixProcess: ChildProcess) {
    this.process = strixProcess
    this.isCapturing = true
    
    // Capture stdout for vulnerability events
    strixProcess.stdout?.on('data', (data: Buffer) => {
      const lines = data.toString().split('\n')
      lines.forEach(line => this.parseLine(line))
    })

    // Capture stderr for errors
    strixProcess.stderr?.on('data', (data: Buffer) => {
      this.emit('error', {
        timestamp: new Date().toISOString(),
        message: data.toString()
      })
    })
  }

  private parseLine(line: string) {
    // Look for vulnerability events
    const vulnMarker = '###VULN_EVENT###'
    if (line.includes(vulnMarker)) {
      try {
        const eventStr = line.split(vulnMarker)[1]
        const event = JSON.parse(eventStr)
        this.emit('vulnerability', event)
        this.eventBuffer.push(event)
      } catch (error) {
        console.error('Failed to parse vulnerability event:', error)
      }
    }
    
    // Also emit raw logs for the log viewer
    this.emit('log', {
      timestamp: new Date().toISOString(),
      level: 'info',
      message: line
    })
  }

  getBufferedEvents() {
    return [...this.eventBuffer]
  }

  stop() {
    this.isCapturing = false
    this.process = null
  }
}
```

#### Update: `tygr/src/app/api/hunts/route.ts`:

```typescript
import { HuntEventCapture } from '@/lib/event-capture'

// In the POST handler after spawning process:
const eventCapture = new HuntEventCapture(huntId)
eventCapture.start(strixProcess)

// Store the capture instance for streaming
global.huntEventCaptures = global.huntEventCaptures || new Map()
global.huntEventCaptures.set(huntId, eventCapture)
```

### Phase 3: Server-Sent Events Endpoint

**Goal**: Create SSE endpoint that streams vulnerability events to frontend.

#### Update: `tygr/src/app/api/hunts/[id]/stream/route.ts`:

```typescript
import { NextRequest } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const huntId = params.id
  
  const eventCapture = global.huntEventCaptures?.get(huntId)
  if (!eventCapture) {
    return new Response('Hunt not found', { status: 404 })
  }

  const stream = new ReadableStream({
    start(controller) {
      const encoder = new TextEncoder()
      
      // Send buffered events first
      const bufferedEvents = eventCapture.getBufferedEvents()
      bufferedEvents.forEach(event => {
        controller.enqueue(
          encoder.encode(`event: vulnerability\ndata: ${JSON.stringify(event)}\n\n`)
        )
      })
      
      // Listen for new vulnerability events
      const vulnerabilityHandler = (event: any) => {
        controller.enqueue(
          encoder.encode(`event: vulnerability\ndata: ${JSON.stringify(event)}\n\n`)
        )
      }
      
      eventCapture.on('vulnerability', vulnerabilityHandler)
      
      // Handle connection close
      request.signal.addEventListener('abort', () => {
        eventCapture.off('vulnerability', vulnerabilityHandler)
        controller.close()
      })
    }
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
    },
  })
}
```

### Phase 4: Frontend Vulnerability Feed Component

**Goal**: Create React component that displays real-time vulnerability feed.

#### New File: `tygr/src/components/vulnerability-feed.tsx`:

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useHuntStore } from '@/stores/hunt-store'
import { Vulnerability } from '@/types'
import { AlertTriangle, ShieldAlert, Bug, Zap } from 'lucide-react'

interface VulnerabilityFeedProps {
  huntId: string
}

export function VulnerabilityFeed({ huntId }: VulnerabilityFeedProps) {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([])
  const [isConnected, setIsConnected] = useState(false)
  const [eventSource, setEventSource] = useState<EventSource | null>(null)
  
  const addVulnerability = useHuntStore(state => state.addVulnerability)

  useEffect(() => {
    // Connect to SSE endpoint
    const es = new EventSource(`/api/hunts/${huntId}/stream`)
    setEventSource(es)
    
    es.onopen = () => {
      setIsConnected(true)
      console.log('Connected to vulnerability stream')
    }
    
    es.onerror = (error) => {
      console.error('Stream error:', error)
      setIsConnected(false)
    }
    
    // Listen for vulnerability events
    es.addEventListener('vulnerability', (event) => {
      const vulnEvent = JSON.parse(event.data)
      const vulnerability: Vulnerability = {
        id: vulnEvent.data.report_id,
        title: vulnEvent.data.title,
        description: vulnEvent.data.content,
        severity: vulnEvent.data.severity as any,
        discoveredBy: vulnEvent.data.agent_id || 'Unknown Agent',
        discoveredAt: vulnEvent.timestamp,
        status: 'new',
        proofOfConcept: '',
        impact: '',
        remediation: '',
        location: vulnEvent.data.location || {},
        tags: []
      }
      
      // Add to local state for immediate display
      setVulnerabilities(prev => [vulnerability, ...prev])
      
      // Add to global store
      addVulnerability(huntId, vulnerability)
    })
    
    return () => {
      es.close()
      setEventSource(null)
    }
  }, [huntId])

  const getSeverityIcon = (severity: string) => {
    switch (severity) {
      case 'critical': return <Zap className="w-5 h-5 text-red-500" />
      case 'high': return <ShieldAlert className="w-5 h-5 text-orange-500" />
      case 'medium': return <Bug className="w-5 h-5 text-yellow-500" />
      default: return <AlertTriangle className="w-5 h-5 text-blue-500" />
    }
  }

  const getSeverityBadgeClass = (severity: string) => {
    switch (severity) {
      case 'critical': return 'bg-red-500/20 text-red-400 border-red-500/30'
      case 'high': return 'bg-orange-500/20 text-orange-400 border-orange-500/30'
      case 'medium': return 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30'
      default: return 'bg-blue-500/20 text-blue-400 border-blue-500/30'
    }
  }

  return (
    <div className="space-y-4">
      {/* Connection Status */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-white">Live Vulnerability Feed</h3>
        <div className="flex items-center space-x-2">
          <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
          <span className="text-sm text-gray-400">
            {isConnected ? 'Live' : 'Disconnected'}
          </span>
        </div>
      </div>

      {/* Vulnerability List */}
      <div className="space-y-3 max-h-96 overflow-y-auto">
        {vulnerabilities.length === 0 ? (
          <div className="text-center py-8 text-gray-400">
            <AlertTriangle className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No vulnerabilities found yet</p>
            <p className="text-sm mt-2">Waiting for scan results...</p>
          </div>
        ) : (
          vulnerabilities.map((vuln) => (
            <div
              key={vuln.id}
              className="bg-gray-800 border border-gray-700 rounded-lg p-4 hover:border-gray-600 transition-colors animate-pulse"
            >
              <div className="flex items-start space-x-3">
                {getSeverityIcon(vuln.severity)}
                <div className="flex-1">
                  <div className="flex items-center space-x-2 mb-2">
                    <span className={`px-2 py-1 rounded text-xs font-medium border ${getSeverityBadgeClass(vuln.severity)}`}>
                      {vuln.severity.toUpperCase()}
                    </span>
                    <h4 className="font-medium text-white">{vuln.title}</h4>
                  </div>
                  
                  <p className="text-gray-300 text-sm mb-3">{vuln.description}</p>
                  
                  <div className="flex items-center space-x-4 text-xs text-gray-400">
                    <span>Found by: {vuln.discoveredBy}</span>
                    <span>•</span>
                    <span>{new Date(vuln.discoveredAt).toLocaleTimeString()}</span>
                    {vuln.location.endpoint && (
                      <>
                        <span>•</span>
                        <span>Endpoint: {vuln.location.endpoint}</span>
                      </>
                    )}
                    {vuln.location.file && (
                      <>
                        <span>•</span>
                        <span>File: {vuln.location.file}</span>
                      </>
                    )}
                  </div>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Stats Footer */}
      {vulnerabilities.length > 0 && (
        <div className="flex items-center justify-between pt-4 border-t border-gray-700">
          <div className="text-sm text-gray-400">
            {vulnerabilities.length} vulnerabilities found
          </div>
          <button className="text-sm text-blue-400 hover:text-blue-300">
            View All Details →
          </button>
        </div>
      )}
    </div>
  )
}
```

### Phase 5: Integration with Hunt Monitor Page

**Goal**: Add vulnerability feed to the existing hunt monitor page.

#### Update: `tygr/src/app/hunts/[id]/page.tsx`:

```typescript
// Add import
import { VulnerabilityFeed } from '@/components/vulnerability-feed'

// In the JSX, replace the vulnerabilities section:
{activeTab === 'findings' && (
  <div className="space-y-6">
    {/* Keep the summary stats */}
    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
      {/* ... existing summary cards ... */}
    </div>

    {/* Add live vulnerability feed */}
    <VulnerabilityFeed huntId={huntId} />
  </div>
)}
```

## Testing Strategy

### 1. Unit Tests
- Test event parsing in `event-capture.ts`
- Test vulnerability component rendering
- Test SSE connection handling

### 2. Integration Tests
- Test full flow: Python tracer → SSE → React component
- Test reconnection logic
- Test event buffering and replay

### 3. Manual Testing
- Run actual Strix scans and verify real-time vulnerability display
- Test with multiple concurrent hunts
- Test network interruption and recovery

## Success Criteria

1. **Functionality**: Vulnerabilities appear in UI within 1 second of discovery
2. **Reliability**: 100% of vulnerability events are captured and displayed
3. **UX**: Smooth animations, clear severity indicators, responsive design
4. **Performance**: No UI lag with 50+ vulnerabilities
5. **Integration**: Works seamlessly with existing hunt monitoring page

## Next Steps

1. Implement enhanced Python tracer with JSON event emission
2. Create event capture and SSE endpoint
3. Build vulnerability feed React component
4. Integrate with existing hunt monitor page
5. Test with real Strix scans